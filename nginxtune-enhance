#!/usr/bin/env python3

"""
Version: 0.3.9
Author: rdbf

Configuration management tool for Nginx used in Enhance hosting environments.
Provides Nginx optimization (http3/quic), security hardening, persistent logging and FastCGI cache control.

Features managed:
- Listen Directives: HTTP/2 and HTTP/3/QUIC listeners with proper IPv6 support
- Protocol Configuration: http2 on, http3 on, and quic_gso directives
- HTTP/3 Compatibility: Alt-Svc headers and FastCGI HTTP_HOST parameter
- Performance Optimization: reuseport and QUIC GSO
- Security Modules: SSL configuration, server hardening, and CMS protection includes
- Logging Features: Persistent logging in user folders and Cloudflare real IP detection
- FastCGI Cache Management: Configurable inactive timeout and cache validity periods
- Client Max Body Size: Change default Nginx client_max_body_size directive

The script analyzes current configuration state, determines required changes,
and applies modifications while preserving Enhance's formatting and structure.
All changes are reversible through JSON configuration toggles.
"""

import os
import shutil
import subprocess
import sys
import json
import re
from datetime import datetime, timedelta
from pathlib import Path

# File paths and constants
SITES_DIR = "/etc/nginx/sites-enabled"
LOG_FILE = "/var/log/nginxtune-enhance.log"
BACKUP_DIR = f"/etc/nginx/backups/{datetime.now().strftime('%Y%m%d_%H%M%S')}"
CONFIG_FILE = "/opt/nginxtune-enhance/config.json"

def load_config():
    """Load feature toggles from config.json with fallback defaults"""
    try:
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return {
            'features': {
                'http3_enable': False,
                'quic_gso_enable': False,
                'ssl_upgrade': False,
                'server_hardening': False,
                'cms_protection': False,
                'persistent_logging': False,
                'real_ip_logging': False,
                'fastcgi_cache_inactive': '60m',
                'fastcgi_cache_valid': '60m',
                'client_max_body_size': '200m'
            },
            'backup_retention_days': 30
        }
    except Exception as e:
        log_message(f"ERROR: Failed to load config.json: {e}", True)
        sys.exit(2)

def log_message(message, is_error=False):
    """Log message with timestamp to log file"""
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    log_entry = f"{timestamp} - {message}\n"
    
    try:
        with open(LOG_FILE, 'a') as f:
            f.write(log_entry)
    except PermissionError as e:
        if is_error:
            print(f"Permission denied writing to log: {e}", file=sys.stderr)
    except OSError as e:
        if is_error:
            print(f"Filesystem error writing to log: {e}", file=sys.stderr)
    except Exception as e:
        if is_error:
            print(f"Unexpected error writing to log: {e}", file=sys.stderr)
    
    if is_error:
        print(log_entry.strip(), file=sys.stderr)

def detect_indentation_safe(lines, line_index):
    """Detect line indentation with fallback"""
    try:
        current_line = lines[line_index]
        indentation = len(current_line) - len(current_line.lstrip())
        return ' ' * indentation
    except:
        return '    '  # 4 spaces fallback

def detect_php_indentation_safe(lines, line_index):
    """Detect PHP location block indentation with fallback"""
    try:
        current_line = lines[line_index]
        base_indent = len(current_line) - len(current_line.lstrip())
        return ' ' * (base_indent + 4)
    except:
        return '                '  # 16 spaces fallback

def create_backup():
    """Create backup directory and copy configs"""
    try:
        Path(BACKUP_DIR).mkdir(parents=True, exist_ok=True)
        
        for conf_file in Path(SITES_DIR).glob("*.conf"):
            shutil.copy2(conf_file, BACKUP_DIR)
        
        log_message(f"Backup created: {BACKUP_DIR}")
        return True
    except Exception as e:
        log_message(f"ERROR: Failed to create backup: {e}", True)
        return False

def restore_backup():
    """Restore from backup directory"""
    try:
        for backup_file in Path(BACKUP_DIR).glob("*.conf"):
            original_path = Path(SITES_DIR) / backup_file.name
            shutil.copy2(backup_file, original_path)
        
        log_message(f"Restored from backup: {BACKUP_DIR}")
        return True
    except Exception as e:
        log_message(f"ERROR: Failed to restore backup: {e}", True)
        return False

def test_nginx_config():
    """Test nginx configuration"""
    try:
        result = subprocess.run(['nginx', '-t'], capture_output=True, text=True)
        return result.returncode == 0, result.stderr
    except Exception as e:
        return False, str(e)

def reload_nginx():
    """Reload nginx service"""
    try:
        result = subprocess.run(['systemctl', 'reload', 'nginx'], capture_output=True, text=True)
        return result.returncode == 0
    except Exception as e:
        log_message(f"ERROR: Failed to reload nginx: {e}", True)
        return False

def cleanup_backup(backup_dir):
    """Remove a specific backup directory after restoration"""
    try:
        if os.path.exists(backup_dir):
            shutil.rmtree(backup_dir)
            log_message(f"Cleaned up backup directory: {backup_dir}")
            return True
        else:
            log_message(f"Backup directory not found for cleanup: {backup_dir}")
            return False
    except Exception as e:
        log_message(f"ERROR: Failed to cleanup backup directory {backup_dir}: {e}", True)
        return False

def cleanup_old_backups(retention_days):
    """Remove backup directories older than specified retention period"""
    try:
        backup_base_dir = "/etc/nginx/backups"
        if not os.path.exists(backup_base_dir):
            return
        
        cutoff_time = datetime.now() - timedelta(days=retention_days)
        removed_count = 0
        
        for backup_dir in os.listdir(backup_base_dir):
            backup_path = os.path.join(backup_base_dir, backup_dir)
            
            # Skip if not a directory
            if not os.path.isdir(backup_path):
                continue
            
            # Parse timestamp from directory name YYYYMMDD_HHMMSS
            try:
                backup_time = datetime.strptime(backup_dir, '%Y%m%d_%H%M%S')
                
                if backup_time < cutoff_time:
                    shutil.rmtree(backup_path)
                    removed_count += 1
                    log_message(f"Removed old backup: {backup_dir}")
                    
            except ValueError:
                # Skip directories with non-standard naming
                log_message(f"Skipping non-standard backup directory: {backup_dir}")
                continue
        
        if removed_count > 0:
            log_message(f"Cleanup completed: removed {removed_count} old backups (older than {retention_days} days)")
        
    except Exception as e:
        log_message(f"ERROR: Failed to cleanup old backups: {e}", True)

def apply_http3_enable(config, mode="check"):
    """Apply HTTP/3 configuration to all configs (includes config_fixes functionality)"""
    features = config.get('features', {})
    http3_enabled = features.get('http3_enable', False)
    
    # Process all conf files
    try:
        conf_files = list(Path(SITES_DIR).glob("*.conf"))
    except Exception as e:
        if mode == "apply":
            log_message(f"ERROR: Failed to scan {SITES_DIR}: {e}", True)
        return False
    
    if not conf_files:
        return False
    
    ALT_SVC_HEADER = 'h3=":443"; ma=86400'
    changes_needed = False
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix
        if filename.startswith('000-'):
            continue
            
        is_default = filename == "default.conf"
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            if mode == "apply":
                log_message(f"ERROR: Failed to read {conf_file}: {e}", True)
            continue
        
        # Check for PHP location blocks
        has_php_location = any('location ~ \\.php$' in line for line in lines)
        
        # Define target state
        if is_default:
            if http3_enabled:
                target_listeners = [
                    'listen 80 default_server reuseport',
                    'listen [::]:80 default_server reuseport',
                    'listen 443 ssl default_server reuseport',
                    'listen [::]:443 ssl default_server reuseport',
                    'listen 443 quic default_server reuseport',
                    'listen [::]:443 quic default_server reuseport'
                ]
                target_directives = ['http2 on', 'http3 on']
            else:
                target_listeners = [
                    'listen 80 default_server reuseport',
                    'listen [::]:80 default_server reuseport',
                    'listen 443 ssl http2 default_server reuseport',
                    'listen [::]:443 ssl http2 default_server reuseport'
                ]
                target_directives = []
            target_server_headers = []
            target_php_additions = []
        else:
            # Site configs
            if http3_enabled:
                target_listeners = [
                    'listen 80',
                    'listen [::]:80',
                    'listen 443 ssl',
                    'listen [::]:443 ssl',
                    'listen 443 quic',
                    'listen [::]:443 quic'
                ]
                target_directives = ['http2 on', 'http3 on']
                target_server_headers = [f"add_header Alt-Svc '{ALT_SVC_HEADER}'"]
                # Only set PHP additions if PHP location blocks exist
                if has_php_location:
                    target_php_additions = [f"add_header Alt-Svc '{ALT_SVC_HEADER}'", 'fastcgi_param HTTP_HOST $host']
                else:
                    target_php_additions = []
            else:
                target_listeners = [
                    'listen 80',
                    'listen [::]:80',
                    'listen 443 ssl http2',
                    'listen [::]:443 ssl http2'
                ]
                target_directives = []
                target_server_headers = []
                target_php_additions = []
        
        # Check current state to see if changes are needed
        current_listeners = []
        current_directives = []
        current_server_headers = []
        current_php_additions = []
        in_php_block = False
        
        for line in lines:
            stripped = line.strip()
            
            # Extract current listen directives
            if stripped.startswith('listen ') and not stripped.startswith('#'):
                if any(port in stripped for port in ['80', '443']):
                    current_listeners.append(stripped.rstrip(';'))
            
            # Extract current protocol directives
            elif stripped in ['http2 on;', 'http3 on;']:
                current_directives.append(stripped.rstrip(';'))
            
            # Extract current server-level headers
            elif f"add_header Alt-Svc '{ALT_SVC_HEADER}'" in line and not in_php_block and not is_default:
                current_server_headers.append(stripped.rstrip(';'))
            
            # Extract current PHP-specific settings
            elif in_php_block and not is_default:
                if f"add_header Alt-Svc '{ALT_SVC_HEADER}'" in line:
                    current_php_additions.append(stripped.rstrip(';'))
                elif 'fastcgi_param HTTP_HOST $host;' in line:
                    current_php_additions.append(stripped.rstrip(';'))
            
            # Track PHP location block boundaries
            elif 'location ~ \\.php$' in stripped and not is_default:
                in_php_block = True
            elif in_php_block and stripped == "}":
                in_php_block = False
        
        # Compare current state vs target state
        listeners_match = set(current_listeners) == set(target_listeners)
        directives_match = set(current_directives) == set(target_directives)
        server_headers_match = set(current_server_headers) == set(target_server_headers)
        
        # Check PHP additions only if PHP location exists
        if not is_default and has_php_location:
            php_additions_match = set(current_php_additions) == set(target_php_additions)
        else:
            php_additions_match = len(target_php_additions) == 0
        
        # Determine if changes needed
        if not (listeners_match and directives_match and server_headers_match and php_additions_match):
            changes_needed = True
            if mode == "check":
                break  # No need to check further files in check mode
        
        # Apply changes in apply mode
        if mode == "apply" and not (listeners_match and directives_match and server_headers_match and php_additions_match):
            new_lines = []
            listeners_added = False
            directives_added = False
            in_php_block = False
            
            for i, line in enumerate(lines):
                stripped = line.strip()
                
                # Remove existing listen directives for ports 80/443
                if stripped.startswith('listen ') and not stripped.startswith('#'):
                    if any(port in stripped for port in ['80', '443']):
                        continue
                
                # Remove existing protocol directives
                elif stripped in ['http2 on;', 'http3 on;']:
                    continue
                
                # Remove existing Alt-Svc headers
                elif f"add_header Alt-Svc '{ALT_SVC_HEADER}'" in line:
                    continue
                
                # Remove existing FastCGI HTTP_HOST parameter
                elif 'fastcgi_param HTTP_HOST $host;' in line:
                    continue
                
                # Insert target listeners after server block opening
                elif 'server {' in line and not listeners_added:
                    new_lines.append(line)
                    # Detect indentation from next non-empty line
                    base_indent = '    '  # Default indentation
                    for j in range(i + 1, min(i + 10, len(lines))):
                        next_line = lines[j]
                        if next_line.strip() and not next_line.strip().startswith('#'):
                            base_indent = next_line[:len(next_line) - len(next_line.lstrip())]
                            break
                    
                    for listener in target_listeners:
                        new_lines.append(f"{base_indent}{listener};\n")
                    listeners_added = True
                    continue
                
                # Insert target directives and headers after server_name
                elif stripped.startswith('server_name') and not directives_added:
                    new_lines.append(line)
                    base_indent = detect_indentation_safe(lines, i)
                    
                    for directive in target_directives:
                        new_lines.append(f"{base_indent}{directive};\n")
                    
                    if not is_default:
                        for header in target_server_headers:
                            new_lines.append(f"{base_indent}{header};\n")
                    
                    directives_added = True
                    continue
                
                # Insert PHP additions at start of PHP location block
                elif 'location ~ \\.php$' in stripped and not is_default and target_php_additions:
                    new_lines.append(line)
                    php_indent = detect_php_indentation_safe(lines, i)
                    for addition in target_php_additions:
                        new_lines.append(f"{php_indent}{addition};\n")
                    continue
                
                else:
                    new_lines.append(line)
            
            # Write modified configuration
            try:
                with open(conf_file, 'w') as f:
                    f.writelines(new_lines)
                
                action = "enabled" if http3_enabled else "disabled"
                log_message(f"http3_enable: {action} - updated {filename}")
                
            except Exception as e:
                log_message(f"ERROR: Failed to write {conf_file}: {e}", True)
                continue
    
    # Return for check mode
    if mode == "check":
        return changes_needed
    
    # Apply mode completed
    return changes_needed

def apply_quic_gso_enable(config, mode="check"):
    """Apply QUIC GSO configuration to all configs"""
    features = config.get('features', {})
    quic_gso_enabled = features.get('quic_gso_enable', False)
    http3_enabled = features.get('http3_enable', False)
    
    # QUIC GSO requires HTTP/3 to be enabled
    effective_quic_gso = quic_gso_enabled and http3_enabled
    
    # Get all conf files
    try:
        conf_files = list(Path(SITES_DIR).glob("*.conf"))
    except Exception as e:
        if mode == "apply":
            log_message(f"ERROR: Failed to scan {SITES_DIR}: {e}", True)
        return False
    
    if not conf_files:
        return False
    
    changes_needed = False
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix
        if filename.startswith('000-'):
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            if mode == "apply":
                log_message(f"ERROR: Failed to read {conf_file}: {e}", True)
            continue
        
        # Check current QUIC GSO state
        has_quic_gso = False
        for line in lines:
            stripped = line.strip()
            if stripped == 'quic_gso on;':
                has_quic_gso = True
                break
        
        # Determine if changes needed
        if has_quic_gso != effective_quic_gso:
            changes_needed = True
            if mode == "check":
                break  # Early exit in check mode
    
    if mode == "check":
        return changes_needed
    
    # Apply mode - make actual changes
    if not changes_needed:
        return False
    
    modified_files = []
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix
        if filename.startswith('000-'):
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            log_message(f"ERROR: Failed to read {conf_file}: {e}", True)
            continue
        
        # Check current state
        has_quic_gso = False
        for line in lines:
            stripped = line.strip()
            if stripped == 'quic_gso on;':
                has_quic_gso = True
                break
        
        # Check if changes are needed
        quic_gso_needs_change = has_quic_gso != effective_quic_gso
        
        if not quic_gso_needs_change:
            continue
        
        # Modify configuration
        new_lines = []
        quic_gso_added = False
        
        for i, line in enumerate(lines):
            stripped = line.strip()
            base_indent = detect_indentation_safe(lines, i)
            
            # Remove existing quic_gso directive when disabled
            if stripped == 'quic_gso on;' and not effective_quic_gso:
                continue
            
            # Insert quic_gso directive after server_name when enabled
            elif (stripped.startswith('server_name') and not stripped.startswith('#') 
                  and effective_quic_gso and not quic_gso_added):
                new_lines.append(line)
                new_lines.append(f"{base_indent}quic_gso on;\n")
                quic_gso_added = True
            
            else:
                new_lines.append(line)
        
        # Write modified configuration
        try:
            with open(conf_file, 'w') as f:
                f.writelines(new_lines)
            modified_files.append(f"{filename} (QUIC GSO directive)")
        except Exception as e:
            log_message(f"ERROR: Failed to write {conf_file}: {e}", True)
            continue
    
    # Log results
    if modified_files:
        action = "enabled" if effective_quic_gso else "disabled"
        for file_info in modified_files:
            log_message(f"quic_gso_enable: {action} - updated {file_info}")
        return True
    
    return False

def apply_include_features(config, mode="check"):
    """Apply ssl_upgrade, server_hardening, and cms_protection includes to site configs"""
    features = config.get('features', {})
    
    # Map features to include directives
    include_mappings = {
        'ssl_upgrade': 'include /opt/nginxtune-enhance/overrides/ssl.conf',
        'server_hardening': 'include /opt/nginxtune-enhance/overrides/hardening.conf', 
        'cms_protection': 'include /opt/nginxtune-enhance/overrides/cms.conf'
    }
    
    # Build expected includes list based on enabled features
    expected_includes = []
    for feature_name, include_line in include_mappings.items():
        if features.get(feature_name, False):
            expected_includes.append(include_line)
    
    # Get site config files
    try:
        conf_files = list(Path(SITES_DIR).glob("*.conf"))
    except Exception as e:
        if mode == "apply":
            log_message(f"ERROR: Failed to scan {SITES_DIR}: {e}", True)
        return False
    
    if not conf_files:
        return False
    
    changes_needed = False
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix
        if filename.startswith('000-'):
            continue
        
        # Skip default.conf (include features only apply to site configs)
        if filename == "default.conf":
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            if mode == "apply":
                log_message(f"ERROR: Failed to read {filename}: {e}", True)
            continue
        
        # Parse current includes - separate managed vs unknown includes
        current_includes = []
        unwanted_includes = []
        manageable_includes = list(include_mappings.values())
        
        for line in lines:
            stripped = line.strip()
            
            # Check for nginxtune-enhance includes
            if 'include /opt/nginxtune-enhance/' in line:
                include_line = stripped.rstrip(';')
                if include_line in manageable_includes:
                    current_includes.append(include_line)
                else:
                    # Unknown or legacy include to be removed
                    unwanted_includes.append(include_line)
        
        # Determine required changes
        includes_to_add = [inc for inc in expected_includes if inc not in current_includes]
        includes_to_remove = [inc for inc in manageable_includes if inc in current_includes and inc not in expected_includes]
        legacy_to_remove = unwanted_includes
        
        # Check if changes needed
        if includes_to_add or includes_to_remove or legacy_to_remove:
            changes_needed = True
            if mode == "check":
                break  # Early exit in check mode
    
    if mode == "check":
        return changes_needed
    
    # Apply mode - make actual changes
    if not changes_needed:
        return False
    
    modified_files = []
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix and default.conf
        if filename.startswith('000-') or filename == "default.conf":
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            log_message(f"ERROR: Failed to read {filename}: {e}", True)
            continue
        
        # Re-parse current state for this file
        current_includes = []
        unwanted_includes = []
        manageable_includes = list(include_mappings.values())
        
        for line in lines:
            stripped = line.strip()
            if 'include /opt/nginxtune-enhance/' in line:
                include_line = stripped.rstrip(';')
                if include_line in manageable_includes:
                    current_includes.append(include_line)
                else:
                    unwanted_includes.append(include_line)
        
        # Determine changes needed for this file
        includes_to_add = [inc for inc in expected_includes if inc not in current_includes]
        includes_to_remove = [inc for inc in manageable_includes if inc in current_includes and inc not in expected_includes]
        legacy_to_remove = unwanted_includes
        
        # Skip if no changes needed
        if not (includes_to_add or includes_to_remove or legacy_to_remove):
            continue
        
        # Modify configuration
        new_lines = []
        includes_processed = False
        base_indent = '    '  # Default indentation
        
        for i, line in enumerate(lines):
            stripped = line.strip()
            
            # Remove unwanted includes (disabled features and legacy)
            should_skip = False
            
            # Check for disabled feature includes to remove
            for include_line in includes_to_remove:
                if stripped == f'{include_line};' or stripped == include_line:
                    should_skip = True
                    break
            
            # Check for legacy includes to remove
            if not should_skip:
                for include_line in legacy_to_remove:
                    if stripped == f'{include_line};' or stripped == include_line:
                        should_skip = True
                        break
            
            if should_skip:
                continue
            
            # Add line normally
            new_lines.append(line)
            
            # Insert new includes after vhost_includes directive
            if 'include vhost_includes/' in line and not includes_processed:
                base_indent = detect_indentation_safe(lines, i)
                for include_line in includes_to_add:
                    new_lines.append(f'{base_indent}{include_line};\n')
                includes_processed = True
        
        # Write modified configuration
        try:
            with open(conf_file, 'w') as f:
                f.writelines(new_lines)
            
            # Log changes
            change_parts = []
            if includes_to_add:
                added_features = [name for name, inc in include_mappings.items() if inc in includes_to_add]
                change_parts.append(f"added {', '.join(added_features)}")
            if includes_to_remove:
                removed_features = [name for name, inc in include_mappings.items() if inc in includes_to_remove]
                change_parts.append(f"removed {', '.join(removed_features)}")
            if legacy_to_remove:
                change_parts.append(f"cleaned up {len(legacy_to_remove)} legacy includes")
            
            change_desc = ', '.join(change_parts)
            modified_files.append(f"{filename} ({change_desc})")
            
        except Exception as e:
            log_message(f"ERROR: Failed to write {filename}: {e}", True)
            continue
    
    # Log changes
    if modified_files:
        # Determine the overall action based on enabled features
        enabled_count = sum(1 for feature_name in include_mappings.keys() if features.get(feature_name, False))
        action = "enabled" if enabled_count > 0 else "disabled"
        
        for file_info in modified_files:
            log_message(f"include_features: {action} - updated {file_info}")
        return True
    
    return False

def apply_logging_features(config, mode="check"):
    """Apply persistent logging and real IP logging configuration to all configs"""
    features = config.get('features', {})
    persistent_logging_enabled = features.get('persistent_logging', False)
    real_ip_logging_enabled = features.get('real_ip_logging', False)
    
    # Get all conf files
    try:
        conf_files = list(Path(SITES_DIR).glob("*.conf"))
    except Exception as e:
        if mode == "apply":
            log_message(f"ERROR: Failed to scan {SITES_DIR}: {e}", True)
        return False
    
    if not conf_files:
        return False
    
    changes_needed = False
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix
        if filename.startswith('000-'):
            continue
        
        # Skip default.conf (logging features only apply to site configs)
        if filename == "default.conf":
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            if mode == "apply":
                log_message(f"ERROR: Failed to read {conf_file}: {e}", True)
            continue
        
        # Parse current state
        has_persistent_log = False
        has_persistent_log_format = False
        has_real_ip_map = False
        has_real_ip_in_original_format = False
        uuid_for_check = None
        
        for line in lines:
            stripped = line.strip()
            if ('access_log /var/log/nginx/' in stripped or 
                ('access_log /var/www/' in stripped and '/logs/webserver.log' in stripped)):
                has_persistent_log = True
            elif 'log_format' in stripped and '_persistent' in stripped:
                has_persistent_log_format = True
            elif 'map $http_cf_connecting_ip $actual_addr' in stripped:
                has_real_ip_map = True
            elif 'log_format' in stripped and '$actual_addr' in stripped and '_persistent' not in stripped:
                has_real_ip_in_original_format = True
            elif 'access_log /var/local/enhance/webserver_logs/' in stripped:
                try:
                    parts = stripped.split()
                    if len(parts) >= 3:
                        log_path = parts[1]
                        uuid_for_check = log_path.split('/')[-1].replace('.log', '')
                except:
                    pass
        
        # Check if directory/ownership work is needed
        needs_directory_creation = False
        needs_ownership_fix = False
        if uuid_for_check and persistent_logging_enabled:
            logs_dir = f"/var/www/{uuid_for_check}/logs"
            
            if not os.path.exists(logs_dir):
                needs_directory_creation = True
            
            if os.path.exists(logs_dir):
                try:
                    parent_stat = os.stat(f"/var/www/{uuid_for_check}")
                    
                    for log_file in os.listdir(logs_dir):
                        log_file_path = os.path.join(logs_dir, log_file)
                        if os.path.isfile(log_file_path):
                            file_stat = os.stat(log_file_path)
                            
                            if file_stat.st_uid != parent_stat.st_uid or file_stat.st_gid != parent_stat.st_gid:
                                needs_ownership_fix = True
                                break
                except:
                    pass
        
        # Determine if changes needed
        current_persistent_state = has_persistent_log and has_persistent_log_format
        current_real_ip_state = has_real_ip_map and has_real_ip_in_original_format
        
        if (current_persistent_state != persistent_logging_enabled or 
            current_real_ip_state != real_ip_logging_enabled or
            needs_directory_creation or
            needs_ownership_fix):
            changes_needed = True
            if mode == "check":
                break
    
    if mode == "check":
        return changes_needed
    
    # Apply mode - make actual changes
    if not changes_needed:
        return False
    
    modified_files = []
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix
        if filename.startswith('000-'):
            continue
        
        # Skip default.conf (logging features only apply to site configs)
        if filename == "default.conf":
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            log_message(f"ERROR: Failed to read {conf_file}: {e}", True)
            continue
        
        # Parse current state
        has_persistent_log = False
        has_persistent_log_format = False
        has_real_ip_map = False
        has_real_ip_in_original_format = False
        uuid_for_ownership = None
        
        for line in lines:
            stripped = line.strip()
            if ('access_log /var/log/nginx/' in stripped or 
                ('access_log /var/www/' in stripped and '/logs/webserver.log' in stripped)):
                has_persistent_log = True
            elif 'log_format' in stripped and '_persistent' in stripped:
                has_persistent_log_format = True
            elif 'map $http_cf_connecting_ip $actual_addr' in stripped:
                has_real_ip_map = True
            elif 'log_format' in stripped and '$actual_addr' in stripped and '_persistent' not in stripped:
                has_real_ip_in_original_format = True
            elif 'access_log /var/local/enhance/webserver_logs/' in stripped:
                try:
                    parts = stripped.split()
                    if len(parts) >= 3:
                        log_path = parts[1]
                        uuid_for_ownership = log_path.split('/')[-1].replace('.log', '')
                except:
                    pass
        
        # Determine if changes needed
        current_persistent_state = has_persistent_log and has_persistent_log_format
        current_real_ip_state = has_real_ip_map and has_real_ip_in_original_format
        
        persistent_needs_change = current_persistent_state != persistent_logging_enabled
        real_ip_needs_change = current_real_ip_state != real_ip_logging_enabled
        
        # Check if ownership needs fixing
        needs_ownership_fix = False
        if uuid_for_ownership and persistent_logging_enabled:
            logs_dir = f"/var/www/{uuid_for_ownership}/logs"
            
            if os.path.exists(logs_dir):
                try:
                    parent_stat = os.stat(f"/var/www/{uuid_for_ownership}")
                    
                    for log_file in os.listdir(logs_dir):
                        log_file_path = os.path.join(logs_dir, log_file)
                        if os.path.isfile(log_file_path):
                            file_stat = os.stat(log_file_path)
                            
                            if file_stat.st_uid != parent_stat.st_uid or file_stat.st_gid != parent_stat.st_gid:
                                needs_ownership_fix = True
                                break
                except:
                    pass
        
        # Fix ownership before checking if config changes needed
        if uuid_for_ownership and persistent_logging_enabled:
            logs_dir = f"/var/www/{uuid_for_ownership}/logs"
            
            if not os.path.exists(logs_dir):
                try:
                    os.makedirs(logs_dir, mode=0o755)
                    parent_stat = os.stat(f"/var/www/{uuid_for_ownership}")
                    os.chown(logs_dir, parent_stat.st_uid, parent_stat.st_gid)
                except Exception as e:
                    log_message(f"ERROR: Failed to create logs directory for {uuid_for_ownership}: {e}", True)
            
            # Fix ownership for all files in logs directory
            if os.path.exists(logs_dir):
                try:
                    parent_stat = os.stat(f"/var/www/{uuid_for_ownership}")
                    
                    for log_file in os.listdir(logs_dir):
                        log_file_path = os.path.join(logs_dir, log_file)
                        if os.path.isfile(log_file_path):
                            file_stat = os.stat(log_file_path)
                            
                            if file_stat.st_uid != parent_stat.st_uid or file_stat.st_gid != parent_stat.st_gid:
                                os.chown(log_file_path, parent_stat.st_uid, parent_stat.st_gid)
                                os.chmod(log_file_path, 0o644)
                except Exception as e:
                    log_message(f"ERROR: Failed to fix log files ownership for {uuid_for_ownership}: {e}", True)
        
        if not (persistent_needs_change or real_ip_needs_change):
            continue
        
        # Modify configuration
        new_lines = []
        real_ip_map_added = False
        persistent_log_added = False
        persistent_log_format_added = False
        
        for i, line in enumerate(lines):
            stripped = line.strip()
            base_indent = detect_indentation_safe(lines, i)
            
            # Remove real IP map when disabled
            if not real_ip_logging_enabled and 'map $http_cf_connecting_ip $actual_addr' in stripped:
                continue
            
            # Remove existing persistent log directive when disabled (both old and new paths)
            elif (('access_log /var/log/nginx/' in stripped or 
                   ('access_log /var/www/' in stripped and '/logs/webserver.log' in stripped)) 
                  and not persistent_logging_enabled):
                continue
            
            # Remove existing persistent log format when disabled
            elif 'log_format' in stripped and '_persistent' in stripped and not persistent_logging_enabled:
                continue
            
            # Update original log_format line for real IP
            elif 'log_format' in stripped and '_persistent' not in stripped:
                if real_ip_logging_enabled and '$remote_addr' in stripped:
                    new_line = line.replace('$remote_addr', '$actual_addr')
                    new_lines.append(new_line)
                elif not real_ip_logging_enabled and '$actual_addr' in stripped:
                    new_line = line.replace('$actual_addr', '$remote_addr')
                    new_lines.append(new_line)
                else:
                    new_lines.append(line)
                
                # Add persistent log format after original log format
                if (persistent_logging_enabled and not persistent_log_format_added 
                    and not has_persistent_log_format):
                    try:
                        parts = stripped.split()
                        if len(parts) >= 2:
                            format_name = parts[1]
                            persistent_format = f'log_format {format_name}_persistent \'$time_local - $actual_addr - $http_cf_ipcountry - $server_protocol - $status - $request_method - $host - $request_uri - $http_user_agent - $upstream_cache_status - $request_time - $upstream_response_time\';'
                            new_lines.append(f"{persistent_format}\n")
                            persistent_log_format_added = True
                    except:
                        pass
            
            # Insert real IP map before fastcgi_cache_path
            elif (stripped.startswith('fastcgi_cache_path') and real_ip_logging_enabled 
                  and not real_ip_map_added and not has_real_ip_map):
                new_lines.append('map $http_cf_connecting_ip $actual_addr { default $http_cf_connecting_ip; "" $remote_addr; }\n')
                new_lines.append(line)
                real_ip_map_added = True
            
            # Insert persistent log directive after enhance access_log
            elif ('access_log /var/local/enhance/webserver_logs/' in stripped 
                  and persistent_logging_enabled and not persistent_log_added):
                new_lines.append(line)
                try:
                    parts = stripped.split()
                    if len(parts) >= 3:
                        log_path = parts[1]
                        log_format = parts[2].rstrip(';')
                        uuid = log_path.split('/')[-1].replace('.log', '')
                        
                        logs_dir = f"/var/www/{uuid}/logs"
                        
                        if not os.path.exists(logs_dir):
                            try:
                                os.makedirs(logs_dir, mode=0o755)
                                parent_stat = os.stat(f"/var/www/{uuid}")
                                os.chown(logs_dir, parent_stat.st_uid, parent_stat.st_gid)
                            except Exception as e:
                                log_message(f"ERROR: Failed to create logs directory for {uuid}: {e}", True)
                        
                        # Fix ownership for all files in logs directory
                        if os.path.exists(logs_dir):
                            try:
                                parent_stat = os.stat(f"/var/www/{uuid}")
                                
                                for log_file in os.listdir(logs_dir):
                                    log_file_path = os.path.join(logs_dir, log_file)
                                    if os.path.isfile(log_file_path):
                                        file_stat = os.stat(log_file_path)
                                        
                                        if file_stat.st_uid != parent_stat.st_uid or file_stat.st_gid != parent_stat.st_gid:
                                            os.chown(log_file_path, parent_stat.st_uid, parent_stat.st_gid)
                                            os.chmod(log_file_path, 0o644)
                            except Exception as e:
                                log_message(f"ERROR: Failed to fix log files ownership for {uuid}: {e}", True)
                        
                        new_lines.append(f"{base_indent}access_log /var/www/{uuid}/logs/webserver.log {log_format}_persistent;\n")
                        persistent_log_added = True
                except:
                    new_lines.append(line)
            
            else:
                new_lines.append(line)
        
        # Write modified configuration
        try:
            with open(conf_file, 'w') as f:
                f.writelines(new_lines)
            
            # Build change description
            change_parts = []
            if persistent_needs_change:
                action = "enabled" if persistent_logging_enabled else "disabled"
                change_parts.append(f"persistent logging {action}")
            if real_ip_needs_change:
                action = "enabled" if real_ip_logging_enabled else "disabled"
                change_parts.append(f"real IP logging {action}")
            
            change_desc = ", ".join(change_parts)
            modified_files.append(f"{filename} ({change_desc})")
        except Exception as e:
            log_message(f"ERROR: Failed to write {conf_file}: {e}", True)
            continue
    
    # Log results
    if modified_files:
        for file_info in modified_files:
            log_message(f"logging_features: updated {file_info}")
        return True
    
    return False

def apply_fastcgi_cache_settings(config, mode="check"):
    """Apply FastCGI cache inactive and valid configuration to all website configs"""
    features = config.get('features', {})
    configured_inactive = features.get('fastcgi_cache_inactive', '60m')
    configured_valid = features.get('fastcgi_cache_valid', '60m')
    
    # Get all conf files
    try:
        conf_files = list(Path(SITES_DIR).glob("*.conf"))
    except Exception as e:
        if mode == "apply":
            log_message(f"ERROR: Failed to scan {SITES_DIR}: {e}", True)
        return False
    
    if not conf_files:
        return False
    
    changes_needed = False
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix
        if filename.startswith('000-'):
            continue
        
        # Skip default.conf (fastcgi cache only applies to website configs)
        if filename == "default.conf":
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            if mode == "apply":
                log_message(f"ERROR: Failed to read {conf_file}: {e}", True)
            continue
        
        # Find and parse current values
        current_inactive_value = None
        current_valid_value = None
        
        for line in lines:
            stripped = line.strip()
            if stripped.startswith('fastcgi_cache_path'):
                # Extract inactive value from line like: inactive=60m
                match = re.search(r'inactive=([^;\s]+)', line)
                if match:
                    current_inactive_value = match.group(1)
            elif stripped.startswith('fastcgi_cache_valid'):
                # Extract valid value from line like: fastcgi_cache_valid 60m;
                match = re.search(r'fastcgi_cache_valid\s+([^;\s]+)', line)
                if match:
                    current_valid_value = match.group(1)
        
        # Compare current vs configured values
        if ((current_inactive_value and current_inactive_value != configured_inactive) or
            (current_valid_value and current_valid_value != configured_valid)):
            changes_needed = True
            if mode == "check":
                break  # Early exit in check mode
    
    if mode == "check":
        return changes_needed
    
    # Apply mode - make actual changes
    if not changes_needed:
        return False
    
    modified_files = []
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix and default.conf
        if filename.startswith('000-') or filename == "default.conf":
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            log_message(f"ERROR: Failed to read {conf_file}: {e}", True)
            continue
        
        # Find current values for this file
        current_inactive_value = None
        current_valid_value = None
        
        for line in lines:
            stripped = line.strip()
            if stripped.startswith('fastcgi_cache_path'):
                match = re.search(r'inactive=([^;\s]+)', line)
                if match:
                    current_inactive_value = match.group(1)
            elif stripped.startswith('fastcgi_cache_valid'):
                match = re.search(r'fastcgi_cache_valid\s+([^;\s]+)', line)
                if match:
                    current_valid_value = match.group(1)
        
        # Check if this file needs changes
        inactive_needs_change = current_inactive_value and current_inactive_value != configured_inactive
        valid_needs_change = current_valid_value and current_valid_value != configured_valid
        
        if not (inactive_needs_change or valid_needs_change):
            continue
        
        # Apply changes to this file
        new_lines = []
        for line in lines:
            stripped = line.strip()
            if stripped.startswith('fastcgi_cache_path') and inactive_needs_change:
                # Replace the inactive value in the line
                new_line = re.sub(r'inactive=[^;\s]+', f'inactive={configured_inactive}', line)
                new_lines.append(new_line)
            elif stripped.startswith('fastcgi_cache_valid') and valid_needs_change:
                # Replace the valid value in the line
                new_line = re.sub(r'fastcgi_cache_valid\s+[^;\s]+', f'fastcgi_cache_valid {configured_valid}', line)
                new_lines.append(new_line)
            else:
                new_lines.append(line)
        
        # Write modified configuration
        try:
            with open(conf_file, 'w') as f:
                f.writelines(new_lines)
            
            modified_files.append(filename)
            
        except Exception as e:
            log_message(f"ERROR: Failed to write {conf_file}: {e}", True)
            continue
    
    # Log results
    if modified_files:
        for filename in modified_files:
            log_message(f"fastcgi_cache_settings: updated {filename} (fastcgi cache settings updated)")
        return True
    
    return False

def apply_client_max_body_size(config, mode="check"):
    """Apply client_max_body_size configuration to all website configs"""
    features = config.get('features', {})
    configured_size = features.get('client_max_body_size', '200m')
    
    # Get all conf files
    try:
        conf_files = list(Path(SITES_DIR).glob("*.conf"))
    except Exception as e:
        if mode == "apply":
            log_message(f"ERROR: Failed to scan {SITES_DIR}: {e}", True)
        return False
    
    if not conf_files:
        return False
    
    # Check if this is a control panel server by looking for 000- files
    is_control_panel_server = any(f.name.startswith('000-') for f in conf_files)
    
    changes_needed = False
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix
        if filename.startswith('000-'):
            continue
        
        # Skip default.conf
        if filename == "default.conf":
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            if mode == "apply":
                log_message(f"ERROR: Failed to read {conf_file}: {e}", True)
            continue
        
        # Check if this vhost serves the control panel UI
        file_content = ''.join(lines)
        is_control_panel_vhost = is_control_panel_server and 'root "/var/www/control-panel/ui"' in file_content
        
        if is_control_panel_vhost:
            # For control panel vhosts, check all directives are correct
            in_location_block = False
            for line in lines:
                stripped = line.strip()
                if stripped.startswith('location ') and '{' in stripped:
                    in_location_block = True
                elif in_location_block and stripped == '}':
                    in_location_block = False
                elif stripped.startswith('client_max_body_size'):
                    match = re.search(r'client_max_body_size\s+([^;\s]+)', line)
                    if match:
                        current = match.group(1)
                        expected = '0' if in_location_block else '2000m'
                        if current != expected:
                            changes_needed = True
                            if mode == "check":
                                break
            if mode == "check" and changes_needed:
                break
        else:
            # For regular vhosts, use original logic
            current_size = None
            for line in lines:
                stripped = line.strip()
                if stripped.startswith('client_max_body_size'):
                    match = re.search(r'client_max_body_size\s+([^;\s]+)', line)
                    if match:
                        current_size = match.group(1)
                        break
            
            if current_size and current_size != configured_size:
                changes_needed = True
                if mode == "check":
                    break
    
    if mode == "check":
        return changes_needed
    
    # Apply mode - make actual changes
    if not changes_needed:
        return False
    
    modified_files = []  # Will store tuples: (filename, is_control_panel_vhost)
    
    for conf_file in conf_files:
        filename = conf_file.name
        
        # Skip system files with 000- prefix and default.conf
        if filename.startswith('000-') or filename == "default.conf":
            continue
        
        try:
            with open(conf_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            log_message(f"ERROR: Failed to read {conf_file}: {e}", True)
            continue
        
        # Check if this vhost serves the control panel UI
        file_content = ''.join(lines)
        is_control_panel_vhost = is_control_panel_server and 'root "/var/www/control-panel/ui"' in file_content
        
        if is_control_panel_vhost:
            # For control panel vhosts, apply context-aware values
            new_lines = []
            in_location_block = False
            for line in lines:
                stripped = line.strip()
                if stripped.startswith('location ') and '{' in stripped:
                    in_location_block = True
                elif in_location_block and stripped == '}':
                    in_location_block = False
                
                if stripped.startswith('client_max_body_size'):
                    target = '0' if in_location_block else '2000m'
                    new_line = re.sub(r'client_max_body_size\s+[^;\s]+', f'client_max_body_size {target}', line)
                    new_lines.append(new_line)
                else:
                    new_lines.append(line)
            
            # Write modified configuration
            try:
                with open(conf_file, 'w') as f:
                    f.writelines(new_lines)
                modified_files.append((filename, True))
            except Exception as e:
                log_message(f"ERROR: Failed to write {conf_file}: {e}", True)
                continue
        else:
            # For regular vhosts, use original logic
            current_size = None
            for line in lines:
                stripped = line.strip()
                if stripped.startswith('client_max_body_size'):
                    match = re.search(r'client_max_body_size\s+([^;\s]+)', line)
                    if match:
                        current_size = match.group(1)
                        break
            
            if not (current_size and current_size != configured_size):
                continue
            
            new_lines = []
            for line in lines:
                stripped = line.strip()
                if stripped.startswith('client_max_body_size'):
                    new_line = re.sub(r'client_max_body_size\s+[^;\s]+', f'client_max_body_size {configured_size}', line)
                    new_lines.append(new_line)
                else:
                    new_lines.append(line)
            
            # Write modified configuration
            try:
                with open(conf_file, 'w') as f:
                    f.writelines(new_lines)
                modified_files.append((filename, False))
            except Exception as e:
                log_message(f"ERROR: Failed to write {conf_file}: {e}", True)
                continue
    
    # Log results
    if modified_files:
        for filename, is_cp in modified_files:
            if is_cp:
                log_message(f"client_max_body_size: updated {filename} (set to original values)")
            else:
                log_message(f"client_max_body_size: updated {filename} (set to {configured_size})")
        return True
    
    return False

def main():
    """Main execution function"""
    if os.geteuid() != 0:
        log_message("ERROR: This script must be run as root", True)
        sys.exit(2)
    
    # Load configuration
    config = load_config()
    
    # Check phase - determine what needs changing
    http3_changes = apply_http3_enable(config, "check")
    quic_gso_changes = apply_quic_gso_enable(config, "check")
    include_changes = apply_include_features(config, "check")
    logging_changes = apply_logging_features(config, "check")
    fastcgi_cache_changes = apply_fastcgi_cache_settings(config, "check")
    body_size_changes = apply_client_max_body_size(config, "check")
    
    # Exit if no changes needed
    if not (http3_changes or quic_gso_changes or include_changes or logging_changes or fastcgi_cache_changes or body_size_changes):
        log_message("Configuration check: All configs up to date")
        # Run cleanup regardless of changes
        retention_days = config.get('backup_retention_days', 30)
        cleanup_old_backups(retention_days)
        sys.exit(0)
    
    # Create backup before making any changes
    if not create_backup():
        log_message("FATAL: Failed to create backup", True)
        sys.exit(2)
    
    # Apply phase - make actual changes
    if http3_changes:
        apply_http3_enable(config, "apply")
    
    if quic_gso_changes:
        apply_quic_gso_enable(config, "apply")
    
    if include_changes:
        apply_include_features(config, "apply")
    
    if logging_changes:
        apply_logging_features(config, "apply")
    
    if fastcgi_cache_changes:
        apply_fastcgi_cache_settings(config, "apply")
    
    if body_size_changes:
        apply_client_max_body_size(config, "apply")

    # Test nginx configuration
    test_passed, test_output = test_nginx_config()
    if not test_passed:
        log_message(f"ERROR: Nginx configuration test failed: {test_output}", True)
        # Restore from backup
        if restore_backup():
            cleanup_backup(BACKUP_DIR)  # Remove backup after restoration
            log_message("Configuration restored from backup")
        else:
            log_message("ERROR: Failed to restore backup", True)
        sys.exit(1)
    
    # Reload nginx
    if reload_nginx():
        log_message("Configuration update completed: nginx reloaded")
    else:
        log_message("ERROR: Failed to reload nginx", True)
        sys.exit(1)
    
    # Run cleanup at end
    retention_days = config.get('backup_retention_days', 30)
    cleanup_old_backups(retention_days)
    
    sys.exit(0)

if __name__ == "__main__":
    main()
